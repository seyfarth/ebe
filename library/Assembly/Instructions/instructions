addss sd ps pd vaddps pd
sub
div
mul
sqrt
min
max
round
punpcklbw
pand
pandn
por
pxor
pch
ucomisd
ucimiss

add
        <h2> add </h2>
        <pre>
        dest = dest + source
        </pre>
        <p>
        The add instruction adds the source value (second operand)
        to the destination (either a register or a memory location).
        The destination can be a 64, 32, 16 or 8 bit register or
        memory location.  The source can be either
        a register, memory location or an immediate value.  You can not use 2
        memory addresses.  You can add either 8, 16 or 32 bit immediate values
        to larger registers and the immediate value will be sign extended.
        </p>
        <pre>
        add     rax, rdx        ; add rdx to rax
        add     r8, 10          ; add 10 to r8
        add     r8, [x]         ; add 64 bit value of x to r8
        add     r8d, [x]        ; add 32 bit value of x to r8d
                                ; top half of r8 will be set to 0
        add     r8w, [x]        ; add 16 bit value of x to r8w
                                ; top 3/4 of r8 will be unchanged
        add     [x], rax        ; add rax to 64 bit variable x
        add     dword [x], 2    ; add 2 to 32 bit variable x
                                ; must specify qword, dword, word or byte
        </pre>
        <h3>
        flags: OF SF ZF AF CF PF
        </h3>
        <p>
and
        and
        dest = dest & source
        flags: SF ZF PF    
        <p>
        The destination (first operand) is replaced with the bitwise and of
        the source value (second operand) and the destination
        (either a register or a memory location).
        The destination can be a 64, 32, 16 or 8 bit register or
        memory location.  The source can be either
        a register, memory location or an immediate value.  You can not use 2
        memory addresses.  You can add either 8, 16 or 32 bit immediate values
        to larger registers and the immediate value will be sign extended.
        </p>
        <pre>
        and     rax, rdx        ; and rdx with rax
                                ; rax gets the result
        and     r8, 10          ; and 10 with r8
        and     r8, [x]         ; and 64 bit value of x with r8
        and     r8d, [x]        ; and 32 bit value of x with r8d
                                ; top half of r8 will be set to 0
        and     r8w, [x]        ; and 16 bit value of x with r8w
                                ; top 3/4 of r8 will be unchanged
        and     [x], rax        ; and rax with 64 bit variable x
        and     word [x], 2     ; and 2 with 16 bit variable x
                                ; must specify qword, dword, word or byte
        </pre>
andnpd  x,x x,m
        and not packed doubles
        dest = ~dest & source
andnps  x,x x,m
        and not packed singles
        dest = ~dest & source
andpd   x,x x,m
        and packed doubles
        dest = dest & source
andps   x,x x,m
        and packed singles
        dest = dest & source
vandnpd x,x,x y,y,y  x.x.m y.y.m x,x y,y  x.m y.m
        and not packed doubles
        dest = ~dest & source
vandnps x,x,x y,y,y  x.x.m y.y.m x,x y,y  x.m y.m
        and not packed singles
        dest = ~dest & source
vandpd  x,x,x y,y,y  x.x.m y.y.m x,x y,y  x.m y.m
        and packed doubles
        dest = dest & source
vandps  x,x,x y,y,y  x.x.m y.y.m x,x y,y  x.m y.m
        and packed singles
        dest = dest & source

bsf	    r,r r,m
        bit scan forward
        flags: ZF=1 if src=0. otherwise dest is lowest 1 bit
bsr	    r,r r,m
        bit scan reverse
        flags: ZF=1 if src=0. otherwise dest is highest 1 bit
bswap   r32 r64       byte reversal
        byte swap
bt      r,r r,i m,r m,i
        bit test
        flags: CF
        accesses an array of bits in memory
btc     r,r r,i m,r m,i
        bit test and complement
        flags: CF
        accesses an array of bits in memory
btr     r,r r,i m,r m,i
        bit test and reset
        flags: CF
        accesses an array of bits in memory
bts     r,r r,i m,r m,i
        bit test and set
        flags: CF
        accesses an array of bits in memory

addpd   x,x x,m
        add packed doubles
        dest[0] = dest[0] + source[0]
        dest[1] = dest[1] + source[1]
addps   x,x x,m
        add packed singles
        dest = dest + source
addsd   x,x x,m
        add scalar double
        dest = dest + source
addss   x,x x,m
        add scalar single
        dest = dest + source
addsubpd   x,x x,m
addsubps   x,x x,m

vaddpd  x,x,x y,y,y  x.x.m y.y.m
        add packed doubles
        dest = dest + source
vaddps  x,x,x y,y,y  x.x.m y.y.m
        add packed singles
        dest = dest + source
vaddsd  x,x,x y,y,y  x.x.m y.y.m
        add scalar double
        dest = dest + source
vaddss  x,x,x y,y,y  x.x.m y.y.m
        add scalar single
        dest = dest + source
vaddsubpd  x,x,x y,y,y  x.x.m y.y.m
vaddsubps  x,x,x y,y,y  x.x.m y.y.m
