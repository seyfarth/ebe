<html>
<head>
<title> move unaligned packed doubles </title>
</head><body>
<h2> movupd - move unaligned packed doubles </h2>
<pre>
dest = source
</pre>
<p>
The movupd instruction moves 2 double precision floating point values
(64 bits each) from the source value (second operand)
to the destination.
The source and the destination can be an XMM register or a memory location.
You can not use 2 memory addresses.
The vmovupd instruction allows moving 4 doubles between YMM registers and
memory.
</p>
<p>
This version does not require memory alignment.
In the original designs movapd was faster than than movupd (move unaligned).
When in doubt use movupd instead.
<p>
movupd moves the values without inspection or conversion.
</p>
<p>
An XMM register is 128 bits total, while CPUs supporting AVX instructions
have an additional 128 bits in each register accessible as YMM registers.
</p>
<pre>
        movupd   xmm1, xmm2     ; moves 2 doubles from xmm2 to xmm1
                                ; leaves the rest of xmm1 unchanged
        movupd   xmm2, [x]      ; moves 2 doubles from variable x to xmm2
                                ; leaves the rest of xmm2 alone
        movupd   [y], xmm0      ; moves 2 doubles from xmm0 to variable y
                                ; moves precisely 128 bits
        vmovupd   xmm1, xmm2    ; moves 2 doubles from xmm2 to xmm1
                                ; leaves the rest of xmm1 unchanged
        vmovupd   ymm1, ymm2    ; moves 4 doubles from ymm2 to ymm1
        vmovupd   ymm2, [x]     ; moves 4 doubles from variable x to ymm2
        vmovupd   [y], ymm0     ; moves 4 doubles from ymm0 to variable y
</pre>
<h3>
flags: none
</h3>
</body>
