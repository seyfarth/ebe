
;       xmm0:  input data

;       move xmm0 to xmm1
;       shift left
;       move xmm0 to xmm2
;       shift right
;
;       use punpcldw to convert low bytes to words
;       use pslldq to shift left 2 bytes
;       use psrldq to shift right 2 bytes
;       use pmullw, paddw
;       use cvtpi2ps to convert dwords to float
;       use punpcklwd to convert low words to dwords
;       use punpckhwd to convert high words to dwords

%macro  multipush 1-*
    %rep  %0
        push    %1
        %rotate 1
    %endrep
%endmacro

%macro  multipop 1-*
    %rep %0
        %rotate -1
        pop     %1
    %endrep
%endmacro

;       sobel ( input, output, rows, cols );
;       char input[rows][cols]
;       float output[rows][cols]
;       boundary of the output array will be unfilled
;
        segment .text
        global  sobel
sobel:
.cols   equ     local1
.rows   equ     local2
.output equ     local3
.input  equ     local4
.bpir   equ     local5
.bpor   equ     local6
        push    rbp
        mov     rbp, rsp
        frame   4, 6, 0
        sub     rsp, frame_size
        cmp     r8, 3
        jl      .noworktodo
        cmp     r9, 3
        jl      .noworktodo
        mov     [rbp+.input], rcx
        mov     [rbp+.output], rdx
        mov     [rbp+.rows], r8
        mov     [rbp+.cols], r9
        mov     [rbp+.bpir], r9
        imul    r9, 4
        mov     [rsp+.bpor], r9

        alias   Rows, rax
        alias   Column, rcx
        alias   Cols, r11
        alias   RowBefore, r8
        alias   CurrentRow, r9
        alias   RowAfter, r10
        alias   OutputRow, rdx

        mov     qRows, [rbp+.rows]; count of rows to process
        mov     qCols, [rbp+.cols]
        sub     qRows, 2
        mov     qRowBefore, [rbp+.input]
        add     qRowBefore, qCols
        mov     qCurrentRow, qRowBefore          ; address of row
        mov     qRowAfter, qRowBefore
        sub     qRowBefore, qCols         ; address of first byte of row-1
        add     qRowAfter, qCols        ; address of first byte of row+1
        add     qOutputRow, [rbp+.bpor] ; address of first row of output
        pxor    xmm13, xmm13
        pxor    xmm14, xmm14
        pxor    xmm15, xmm15
.more_rows:
        mov     qColumn, 1          ; first column to process
.more_cols:
        movdqu  xmm0, [qRowBefore+qColumn-1]        ; data for 1st row of 3
        movdqu  xmm1, xmm0
        movdqu  xmm2, xmm0
        pxor    xmm9, xmm9
        pxor    xmm10, xmm10
        pxor    xmm11, xmm11
        pxor    xmm12, xmm12
        psrldq  xmm1, 1
        psrldq  xmm2, 2

;       After the shifts
;
;       xmm0:   a b c d e f g h i j k l m n o p
;       xmm1:   0 a b c d e f g h i j k l m n o
;       xmm2:   0 0 a b c d e f g h i j k l m n

        movdqa  xmm3, xmm0
        movdqa  xmm4, xmm1
        movdqa  xmm5, xmm2
        punpcklbw   xmm3, xmm13
        punpcklbw   xmm4, xmm14
        punpcklbw   xmm5, xmm15         ; 8 values for 1st row

;       After unpacking low bytes to words
;
;       xmm3:   0a 0b 0c 0d 0e 0f 0g 0h
;       xmm4:   00 0a 0b 0c 0d 0e 0f 0g
;       xmm5:   00 00 0a 0b 0c 0d 0e 0f

        psubw   xmm11, xmm3     ; -1 for Gx
        paddw   xmm11, xmm5     ; +1 for Gx; done for first 8 of 1st row
        psubw   xmm9, xmm3      ; -1 for Gy
        psubw   xmm9, xmm4      ; -2 for Gy
        psubw   xmm9, xmm4      
        psubw   xmm9, xmm5      ; -1 for Gy, done for first 8 of 1st row
        punpckhbw  xmm0, xmm13
        punpckhbw  xmm1, xmm14
        punpckhbw  xmm2, xmm15

;       After unpacking high bytes to words
;
;       xmm0:   0i 0j 0k 0l 0m 0n 0o 0p
;       xmm1:   0h 0i 0j 0k 0l 0m 0n 0o
;       xmm2:   0g 0h 0i 0j 0k 0l 0m 0n

        psubw   xmm12, xmm0     ; -1 for Gx
        paddw   xmm12, xmm2     ; +1 for Gx; done for 1st row
        psubw   xmm10, xmm0     ; -1 for Gy
        psubw   xmm10, xmm1     ; -2 for Gy
        psubw   xmm10, xmm1
        psubw   xmm10, xmm2     ; -1 for Gy; done for 1st row

        movdqu  xmm0, [qCurrentRow+qColumn-1]        ; data for 2nd row of 3
        movdqu  xmm2, xmm0
        psrldq  xmm1, 1
        psrldq  xmm2, 2

;       After the shifts
;
;       xmm0:   a b c d e f g h i j k l m n o p
;       xmm1:   0 a b c d e f g h i j k l m n o
;       xmm2:   0 0 a b c d e f g h i j k l m n

        movdqa  xmm3, xmm0
        movdqa  xmm4, xmm1
        movdqa  xmm5, xmm2
        punpcklbw   xmm3, xmm13
        punpcklbw   xmm4, xmm14
        punpcklbw   xmm5, xmm15         ; 8 values for 1st row

;       After unpacking low bytes to words
;
;       xmm3:   0a 0b 0c 0d 0e 0f 0g 0h
;       xmm4:   00 0a 0b 0c 0d 0e 0f 0g
;       xmm5:   00 00 0a 0b 0c 0d 0e 0f

        psubw   xmm11, xmm3     ; -2 for Gx
        psubw   xmm11, xmm3
        paddw   xmm11, xmm5     ; +2 for Gx
        paddw   xmm11, xmm5
        punpckhbw  xmm0, xmm13
        punpckhbw  xmm1, xmm14
        punpckhbw  xmm2, xmm15

;       After unpacking high bytes to words
;
;       xmm0:   0i 0j 0k 0l 0m 0n 0o 0p
;       xmm1:   0h 0i 0j 0k 0l 0m 0n 0o
;       xmm2:   0g 0h 0i 0j 0k 0l 0m 0n

        psubw   xmm12, xmm0     ; -2 for Gx
        psubw   xmm12, xmm0
        paddw   xmm12, xmm2     ; +2 for Gx
        paddw   xmm12, xmm2

        movdqu  xmm0, [qRowAfter+qColumn-1]        ; data for 3rd row of 3
        movdqu  xmm1, xmm0
        movdqu  xmm2, xmm0
        psrldq  xmm1, 1
        psrldq  xmm2, 2

;       After the shifts
;
;       xmm0:   a b c d e f g h i j k l m n o p
;       xmm1:   0 a b c d e f g h i j k l m n o
;       xmm2:   0 0 a b c d e f g h i j k l m n

        movdqa  xmm3, xmm0
        movdqa  xmm4, xmm1
        movdqa  xmm5, xmm2
        punpcklbw   xmm3, xmm13
        punpcklbw   xmm4, xmm14
        punpcklbw   xmm5, xmm15         ; 8 values for 3rd row

;       After unpacking low bytes to words
;
;       xmm3:   0a 0b 0c 0d 0e 0f 0g 0h
;       xmm4:   00 0a 0b 0c 0d 0e 0f 0g
;       xmm5:   00 00 0a 0b 0c 0d 0e 0f

        psubw   xmm11, xmm3     ; -1 for Gx
        paddw   xmm11, xmm5     ; +1 for Gx
        paddw   xmm9, xmm3      ; +1 for Gy
        paddw   xmm9, xmm4      ; +2 for Gy
        paddw   xmm9, xmm4
        paddw   xmm9, xmm5      ; +1 for Gy
        punpckhbw  xmm0, xmm13
        punpckhbw  xmm1, xmm14
        punpckhbw  xmm2, xmm15

;       After unpacking high bytes to words
;
;       xmm0:   0i 0j 0k 0l 0m 0n 0o 0p
;       xmm1:   0h 0i 0j 0k 0l 0m 0n 0o
;       xmm2:   0g 0h 0i 0j 0k 0l 0m 0n

        psubw   xmm12, xmm0     ; -1 for Gx
        paddw   xmm12, xmm2     ; +1 for Gx
        paddw   xmm10, xmm0     ; +1 for Gy
        paddw   xmm10, xmm1     ; +2 for Gy
        paddw   xmm10, xmm1
        paddw   xmm10, xmm2     ; +1 for Gy

        pmullw  xmm9, xmm9      ; square Gy values
        pmullw  xmm10, xmm10    ; square Gy values
        pmullw  xmm11, xmm11    ; square Gx values
        pmullw  xmm12, xmm12    ; square Gx values
        paddw   xmm9, xmm11     ; sum of squares
        paddw   xmm10, xmm12    ; sum of square
        movdqa  xmm1, xmm9
        movdqa  xmm3, xmm10
        punpcklwd xmm9, xmm13   ; Convert low 4 words to double words
        punpckhwd xmm1, xmm13   ; Convert high 4 words to double words
        punpcklwd xmm10, xmm13  ; Convert low 4 words to double words
        punpckhwd xmm3, xmm13   ; Convert high 4 words to double words
;
;       After these unpacking steps
;
;       xmm0:   ss1   ss2   ss3   ss4
;       xmm1:   ss5   ss5   ss7   ss8
;       xmm10;  ss9   ss10  ss11  ss12
;       xmm3:   ss13  ss14  ss17  ss16

        cvtdq2ps  xmm0, xmm9    ; Convert to floating point
        cvtdq2ps  xmm1, xmm1    ; Convert to floating point
        cvtdq2ps  xmm2, xmm10   ; Convert to floating point
        cvtdq2ps  xmm3, xmm3    ; Convert to floating point
        sqrtps    xmm0, xmm0    ; Take sqrt to get magnitude
        sqrtps    xmm1, xmm1    ; Take sqrt to get magnitude
        sqrtps    xmm2, xmm2    ; Take sqrt to get magnitude
        sqrtps    xmm3, xmm3    ; Take sqrt to get magnitude
        movups    [qOutputRow+qColumn*4], xmm0
        movups    [qOutputRow+qColumn*4+16], xmm1
        movups    [qOutputRow+qColumn*4+32], xmm2
        movlps    [qOutputRow+qColumn*4+48], xmm3

        add     qColumn, 14         ; process 14 Sobel values
        cmp     qColumn, qCols
        jl      .more_cols
        
        add     qRowBefore, qCols
        add     qCurrentRow, qCols
        add     qRowAfter, qCols
        add     qOutputRow, [rbp+.bpor]
        sub     qRows, 1          ; 1 fewer row to process
        cmp     qRows, 0
        jg      .more_rows
.noworktodo:
        leave
        ret
